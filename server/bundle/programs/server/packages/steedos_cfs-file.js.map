{"version":3,"sources":["meteor://ðŸ’»app/packages/steedos:cfs-file/checkNpm.js","meteor://ðŸ’»app/packages/steedos:cfs-file/fsFile-common.js","meteor://ðŸ’»app/packages/steedos:cfs-file/fsFile-server.js"],"names":["checkNpmVersions","module","link","v","require","temp","FS","File","ref","createdByTransform","self","isBasicObject","Utility","extend","cloneFileRecord","full","attachData","prototype","EventEmitter","fsFileAttachData","data","options","callback","Error","urlOpts","name","updatedAt","lastModifiedDate","size","setData","type","Blob","Date","slice","Meteor","isClient","result","call","original","error","debug","console","log","DataMan","setName","getFileExtension","length","getFileName","uploadProgress","getFileRecord","uploadedAt","Math","round","chunkCount","chunkSum","controlledByDeps","Deps","active","getCollection","collection","collectionName","_collections","isMounted","_id","fileRecord","files","findOne","update","modifier","JSON","stringify","defaultCallback","err","count","_saveChanges","what","mod","$set","info","copies","remove","res","getExtension","extension","checkContentType","fsFile","storeName","startOfType","hasStored","store","indexOf","isImage","isVideo","isAudio","formattedSize","fsFileFormattedSize","numeral","hash","format","formatString","isUploaded","optimistic","isEmpty","key","hasCopy","getCopyInfo","_getInfo","updateFileRecordFirst","_setInfo","property","value","save","newName","setFileExtension","onStoredCallback","isServer","on","newStoreName","removeListener","arguments","callee","bind","fileId","Tracker","autorun","c","stop","setTimeout","invalidate","onStored","onStoredSync","wrapAsync","obj","Object","getPrototypeOf","__proto__","object","constructor","logCopyFailure","maxTries","TempStore","ensureForFile","now","currentCount","failures","failedPermanently","doneTrying","createReadStream","exists","storage","storesLookup","primaryStore","adapter","createWriteStream","FileWorker","copy","transform","newId","insert","newFile","oldKey","hasOwnProperty","sourceFileStorage","fileKey","copyStoreData","methods","url","check","String","unblock","response","HTTP","headers","file","_copyStoreData","fileObj","sourceKey","destinationKey","readStream","createReadStreamForFileKey","writeStream","createWriteStreamForFileKey","once","pipe","copyData","sourceStoreName","targetStoreName","move","sourceStoreValues","copyKey","cloneDataToStore","targetStoreValues","createdAt","$unset","moveData","_copyDataFromStoreToStore","sourceStorage","targetStorage","targetKey","safeOnce"],"mappings":"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","file":"/packages/steedos_cfs-file.js","sourcesContent":["// fix warning: xxx not installed\r\nrequire(\"temp/package.json\");\r\n\r\nimport { checkNpmVersions } from 'meteor/tmeasday:check-npm-versions';\r\ncheckNpmVersions({\r\n\ttemp: \"0.7.0\" // for tests only\r\n}, 'steedos:cfs-file');","/**\r\n * @method FS.File\r\n * @namespace FS.File\r\n * @public\r\n * @constructor\r\n * @param {object|FS.File|data to attach} [ref] Another FS.File instance, a filerecord, or some data to pass to attachData\r\n */\r\nFS.File = function(ref, createdByTransform) {\r\n  var self = this;\r\n\r\n  self.createdByTransform = !!createdByTransform;\r\n\r\n  if (ref instanceof FS.File || isBasicObject(ref)) {\r\n    // Extend self with filerecord related data\r\n    FS.Utility.extend(self, FS.Utility.cloneFileRecord(ref, {full: true}));\r\n  } else if (ref) {\r\n    self.attachData(ref);\r\n  }\r\n};\r\n\r\n// An FS.File can emit events\r\nFS.File.prototype = new EventEmitter();\r\n\r\n/**\r\n * @method FS.File.prototype.attachData\r\n * @public\r\n * @param {File|Blob|Buffer|ArrayBuffer|Uint8Array|String} data The data that you want to attach to the file.\r\n * @param {Object} [options] Options\r\n * @param {String} [options.type] The data content (MIME) type, if known.\r\n * @param {String} [options.headers] When attaching a URL, headers to be used for the GET request (currently server only)\r\n * @param {String} [options.auth] When attaching a URL, \"username:password\" to be used for the GET request (currently server only)\r\n * @param {Function} [callback] Callback function, callback(error). On the client, a callback is required if data is a URL.\r\n * @returns {FS.File} This FS.File instance.\r\n *\r\n */\r\nFS.File.prototype.attachData = function fsFileAttachData(data, options, callback) {\r\n  var self = this;\r\n\r\n  if (!callback && typeof options === \"function\") {\r\n    callback = options;\r\n    options = {};\r\n  }\r\n  options = options || {};\r\n\r\n  if (!data) {\r\n    throw new Error('FS.File.attachData requires a data argument with some data');\r\n  }\r\n\r\n  var urlOpts;\r\n\r\n  // Set any other properties we can determine from the source data\r\n  // File\r\n  if (typeof File !== \"undefined\" && data instanceof File) {\r\n    self.name(data.name);\r\n    self.updatedAt(data.lastModifiedDate);\r\n    self.size(data.size);\r\n    setData(data.type);\r\n  }\r\n  // Blob\r\n  else if (typeof Blob !== \"undefined\" && data instanceof Blob) {\r\n    self.name(data.name);\r\n    self.updatedAt(new Date());\r\n    self.size(data.size);\r\n    setData(data.type);\r\n  }\r\n  // URL: we need to do a HEAD request to get the type because type\r\n  // is required for filtering to work.\r\n  else if (typeof data === \"string\" && (data.slice(0, 5) === \"http:\" || data.slice(0, 6) === \"https:\")) {\r\n    urlOpts = FS.Utility.extend({}, options);\r\n    if (urlOpts.type) {\r\n      delete urlOpts.type;\r\n    }\r\n\r\n    if (!callback) {\r\n      if (Meteor.isClient) {\r\n        throw new Error('FS.File.attachData requires a callback when attaching a URL on the client');\r\n      }\r\n      var result = Meteor.call('_cfs_getUrlInfo', data, urlOpts);\r\n      FS.Utility.extend(self, {original: result});\r\n      setData(result.type);\r\n    } else {\r\n      Meteor.call('_cfs_getUrlInfo', data, urlOpts, function (error, result) {\r\n        FS.debug && console.log(\"URL HEAD RESULT:\", result);\r\n        if (error) {\r\n          callback(error);\r\n        } else {\r\n          var type = result.type || options.type;\r\n          if (! type) {\r\n            throw new Error('FS.File.attachData got a URL for which it could not determine the MIME type and none was provided using options.type');\r\n          }\r\n          FS.Utility.extend(self, {original: result});\r\n          setData(type);\r\n        }\r\n      });\r\n    }\r\n  }\r\n  // Everything else\r\n  else {\r\n    setData(options.type);\r\n  }\r\n\r\n  // Set the data\r\n  function setData(type) {\r\n    self.data = new DataMan(data, type, urlOpts);\r\n\r\n    // Update the type to match what the data is\r\n    self.type(self.data.type());\r\n\r\n    // Update the size to match what the data is.\r\n    // It's always safe to call self.data.size() without supplying a callback\r\n    // because it requires a callback only for URLs on the client, and we\r\n    // already added size for URLs when we got the result from '_cfs_getUrlInfo' method.\r\n    if (!self.size()) {\r\n      if (callback) {\r\n        self.data.size(function (error, size) {\r\n          if (error) {\r\n            callback && callback(error);\r\n          } else {\r\n            self.size(size);\r\n            setName();\r\n          }\r\n        });\r\n      } else {\r\n        self.size(self.data.size());\r\n        setName();\r\n      }\r\n    } else {\r\n      setName();\r\n    }\r\n  }\r\n\r\n  function setName() {\r\n    // See if we can extract a file name from URL or filepath\r\n    if (!self.name() && typeof data === \"string\") {\r\n      // name from URL\r\n      if (data.slice(0, 5) === \"http:\" || data.slice(0, 6) === \"https:\") {\r\n        if (FS.Utility.getFileExtension(data).length) {\r\n          // for a URL we assume the end is a filename only if it has an extension\r\n          self.name(FS.Utility.getFileName(data));\r\n        }\r\n      }\r\n      // name from filepath\r\n      else if (data.slice(0, 5) !== \"data:\") {\r\n        self.name(FS.Utility.getFileName(data));\r\n      }\r\n    }\r\n\r\n    callback && callback();\r\n  }\r\n\r\n  return self; //allow chaining\r\n};\r\n\r\n/**\r\n * @method FS.File.prototype.uploadProgress\r\n * @public\r\n * @returns {number} The server confirmed upload progress\r\n */\r\nFS.File.prototype.uploadProgress = function() {\r\n  var self = this;\r\n  // Make sure our file record is updated\r\n  self.getFileRecord();\r\n\r\n  // If fully uploaded, return 100\r\n  if (self.uploadedAt) {\r\n    return 100;\r\n  }\r\n  // Otherwise return the confirmed progress or 0\r\n  else {\r\n    return Math.round((self.chunkCount || 0) / (self.chunkSum || 1) * 100);\r\n  }\r\n};\r\n\r\n/**\r\n * @method FS.File.prototype.controlledByDeps\r\n * @public\r\n * @returns {FS.Collection} Returns true if this FS.File is reactive\r\n *\r\n * > Note: Returns true if this FS.File object was created by a FS.Collection\r\n * > and we are in a reactive computations. What does this mean? Well it should\r\n * > mean that our fileRecord is fully updated by Meteor and we are mounted on\r\n * > a collection\r\n */\r\nFS.File.prototype.controlledByDeps = function() {\r\n  var self = this;\r\n  return self.createdByTransform && Deps.active;\r\n};\r\n\r\n/**\r\n * @method FS.File.prototype.getCollection\r\n * @public\r\n * @returns {FS.Collection} Returns attached collection or undefined if not mounted\r\n */\r\nFS.File.prototype.getCollection = function() {\r\n  // Get the collection reference\r\n  var self = this;\r\n\r\n  // If we already made the link then do no more\r\n  if (self.collection) {\r\n    return self.collection;\r\n  }\r\n\r\n  // If we don't have a collectionName then there's not much to do, the file is\r\n  // not mounted yet\r\n  if (!self.collectionName) {\r\n    // Should not throw an error here - could be common that the file is not\r\n    // yet mounted into a collection\r\n    return;\r\n  }\r\n\r\n  // Link the collection to the file\r\n  self.collection = FS._collections[self.collectionName];\r\n\r\n  return self.collection; //possibly undefined, but that's desired behavior\r\n};\r\n\r\n/**\r\n * @method FS.File.prototype.isMounted\r\n * @public\r\n * @returns {FS.Collection} Returns attached collection or undefined if not mounted\r\n */\r\nFS.File.prototype.isMounted = FS.File.prototype.getCollection;\r\n\r\n/**\r\n * @method FS.File.prototype.getFileRecord Returns the fileRecord\r\n * @public\r\n * @returns {object} The filerecord\r\n */\r\nFS.File.prototype.getFileRecord = function() {\r\n  var self = this;\r\n  // Check if this file object fileRecord is kept updated by Meteor, if so\r\n  // return self\r\n  if (self.controlledByDeps()) {\r\n    return self;\r\n  }\r\n  // Go for manually updating the file record\r\n  if (self.isMounted()) {\r\n    FS.debug && console.log('GET FILERECORD: ' + self._id);\r\n\r\n    // Return the fileRecord or an empty object\r\n    var fileRecord = self.collection.files.findOne({_id: self._id}) || {};\r\n    FS.Utility.extend(self, fileRecord);\r\n    return fileRecord;\r\n  } else {\r\n    // We return an empty object, this way users can still do `getRecord().size`\r\n    // Without getting an error\r\n    return {};\r\n  }\r\n};\r\n\r\n/**\r\n * @method FS.File.prototype.update\r\n * @public\r\n * @param {modifier} modifier\r\n * @param {object} [options]\r\n * @param {function} [callback]\r\n *\r\n * Updates the fileRecord.\r\n */\r\nFS.File.prototype.update = function(modifier, options, callback) {\r\n  var self = this;\r\n\r\n  FS.debug && console.log('UPDATE: ' + JSON.stringify(modifier));\r\n\r\n  // Make sure we have options and callback\r\n  if (!callback && typeof options === 'function') {\r\n    callback = options;\r\n    options = {};\r\n  }\r\n  callback = callback || FS.Utility.defaultCallback;\r\n\r\n  if (!self.isMounted()) {\r\n    callback(new Error(\"Cannot update a file that is not associated with a collection\"));\r\n    return;\r\n  }\r\n\r\n  // Call collection update - File record\r\n  return self.collection.files.update({_id: self._id}, modifier, options, function(err, count) {\r\n    // Update the fileRecord if it was changed and on the client\r\n    // The server-side methods will pull the fileRecord if needed\r\n    if (count > 0 && Meteor.isClient)\r\n      self.getFileRecord();\r\n    // Call callback\r\n    callback(err, count);\r\n  });\r\n};\r\n\r\n/**\r\n * @method FS.File.prototype._saveChanges\r\n * @private\r\n * @param {String} [what] \"_original\" to save original info, or a store name to save info for that store, or saves everything\r\n *\r\n * Updates the fileRecord from values currently set on the FS.File instance.\r\n */\r\nFS.File.prototype._saveChanges = function(what) {\r\n  var self = this;\r\n\r\n  if (!self.isMounted()) {\r\n    return;\r\n  }\r\n\r\n  FS.debug && console.log(\"FS.File._saveChanges:\", what || \"all\");\r\n\r\n  var mod = {$set: {}};\r\n  if (what === \"_original\") {\r\n    mod.$set.original = self.original;\r\n  } else if (typeof what === \"string\") {\r\n    var info = self.copies[what];\r\n    if (info) {\r\n      mod.$set[\"copies.\" + what] = info;\r\n    }\r\n  } else {\r\n    mod.$set.original = self.original;\r\n    mod.$set.copies = self.copies;\r\n  }\r\n\r\n  self.update(mod);\r\n};\r\n\r\n/**\r\n * @method FS.File.prototype.remove\r\n * @public\r\n * @param {Function} [callback]\r\n * @returns {number} Count\r\n *\r\n * Remove the current file from its FS.Collection\r\n */\r\nFS.File.prototype.remove = function(callback) {\r\n  var self = this;\r\n\r\n  FS.debug && console.log('REMOVE: ' + self._id);\r\n\r\n  callback = callback || FS.Utility.defaultCallback;\r\n\r\n  if (!self.isMounted()) {\r\n    callback(new Error(\"Cannot remove a file that is not associated with a collection\"));\r\n    return;\r\n  }\r\n\r\n  return self.collection.files.remove({_id: self._id}, function(err, res) {\r\n    if (!err) {\r\n      delete self._id;\r\n      delete self.collection;\r\n      delete self.collectionName;\r\n    }\r\n    callback(err, res);\r\n  });\r\n};\r\n\r\n/**\r\n * @method FS.File.prototype.moveTo\r\n * @param {FS.Collection} targetCollection\r\n * @private // Marked private until implemented\r\n * @todo Needs to be implemented\r\n *\r\n * Move the file from current collection to another collection\r\n *\r\n * > Note: Not yet implemented\r\n */\r\n\r\n/**\r\n * @method FS.File.prototype.getExtension Returns the lowercase file extension\r\n * @public\r\n * @deprecated Use the `extension` getter/setter method instead.\r\n * @param {Object} [options]\r\n * @param {String} [options.store] - Store name. Default is the original extension.\r\n * @returns {string} The extension eg.: `jpg` or if not found then an empty string ''\r\n */\r\nFS.File.prototype.getExtension = function(options) {\r\n  var self = this;\r\n  return self.extension(options);\r\n};\r\n\r\nfunction checkContentType(fsFile, storeName, startOfType) {\r\n  var type;\r\n  if (storeName && fsFile.hasStored(storeName)) {\r\n    type = fsFile.type({store: storeName});\r\n  } else {\r\n    type = fsFile.type();\r\n  }\r\n  if (typeof type === \"string\") {\r\n    return type.indexOf(startOfType) === 0;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * @method FS.File.prototype.isImage Is it an image file?\r\n * @public\r\n * @param {object} [options]\r\n * @param {string} [options.store] The store we're interested in\r\n *\r\n * Returns true if the copy of this file in the specified store has an image\r\n * content type. If the file object is unmounted or doesn't have a copy for\r\n * the specified store, or if you don't specify a store, this method checks\r\n * the content type of the original file.\r\n */\r\nFS.File.prototype.isImage = function(options) {\r\n  return checkContentType(this, (options || {}).store, 'image/');\r\n};\r\n\r\n/**\r\n * @method FS.File.prototype.isVideo Is it a video file?\r\n * @public\r\n * @param {object} [options]\r\n * @param {string} [options.store] The store we're interested in\r\n *\r\n * Returns true if the copy of this file in the specified store has a video\r\n * content type. If the file object is unmounted or doesn't have a copy for\r\n * the specified store, or if you don't specify a store, this method checks\r\n * the content type of the original file.\r\n */\r\nFS.File.prototype.isVideo = function(options) {\r\n  return checkContentType(this, (options || {}).store, 'video/');\r\n};\r\n\r\n/**\r\n * @method FS.File.prototype.isAudio Is it an audio file?\r\n * @public\r\n * @param {object} [options]\r\n * @param {string} [options.store] The store we're interested in\r\n *\r\n * Returns true if the copy of this file in the specified store has an audio\r\n * content type. If the file object is unmounted or doesn't have a copy for\r\n * the specified store, or if you don't specify a store, this method checks\r\n * the content type of the original file.\r\n */\r\nFS.File.prototype.isAudio = function(options) {\r\n  return checkContentType(this, (options || {}).store, 'audio/');\r\n};\r\n\r\n/**\r\n * @method FS.File.prototype.formattedSize\r\n * @public\r\n * @param  {Object} options\r\n * @param  {String} [options.store=none,display original file size] Which file do you want to get the size of?\r\n * @param  {String} [options.formatString='0.00 b'] The `numeral` format string to use.\r\n * @return {String} The file size formatted as a human readable string and reactively updated.\r\n *\r\n * * You must add the `numeral` package to your app before you can use this method.\r\n * * If info is not found or a size can't be determined, it will show 0.\r\n */\r\nFS.File.prototype.formattedSize = function fsFileFormattedSize(options) {\r\n  var self = this;\r\n\r\n  if (typeof numeral !== \"function\")\r\n    throw new Error(\"You must add the numeral package if you call FS.File.formattedSize\");\r\n\r\n  options = options || {};\r\n  options = options.hash || options;\r\n\r\n  var size = self.size(options) || 0;\r\n  return numeral(size).format(options.formatString || '0.00 b');\r\n};\r\n\r\n/**\r\n * @method FS.File.prototype.isUploaded Is this file completely uploaded?\r\n * @public\r\n * @returns {boolean} True if the number of uploaded bytes is equal to the file size.\r\n */\r\nFS.File.prototype.isUploaded = function() {\r\n  var self = this;\r\n\r\n  // Make sure we use the updated file record\r\n  self.getFileRecord();\r\n\r\n  return !!self.uploadedAt;\r\n};\r\n\r\n/**\r\n * @method FS.File.prototype.hasStored\r\n * @public\r\n * @param {string} storeName Name of the store\r\n * @param {boolean} [optimistic=false] In case that the file record is not found, read below\r\n * @returns {boolean} Is a version of this file stored in the given store?\r\n *\r\n * > Note: If the file is not published to the client or simply not found:\r\n * this method cannot know for sure if it exists or not. The `optimistic`\r\n * param is the boolean value to return. Are we `optimistic` that the copy\r\n * could exist. This is the case in `FS.File.url` we are optimistic that the\r\n * copy supplied by the user exists.\r\n */\r\nFS.File.prototype.hasStored = function(storeName, optimistic) {\r\n  var self = this;\r\n  // Make sure we use the updated file record\r\n  self.getFileRecord();\r\n  // If we havent the published data then\r\n  if (FS.Utility.isEmpty(self.copies)) {\r\n    return !!optimistic;\r\n  }\r\n  if (typeof storeName === \"string\") {\r\n    // Return true only if the `key` property is present, which is not set until\r\n    // storage is complete.\r\n    return !!(self.copies && self.copies[storeName] && self.copies[storeName].key);\r\n  }\r\n  return false;\r\n};\r\n\r\n// Backwards compatibility\r\nFS.File.prototype.hasCopy = FS.File.prototype.hasStored;\r\n\r\n/**\r\n * @method FS.File.prototype.getCopyInfo\r\n * @public\r\n * @deprecated Use individual methods with `store` option instead.\r\n * @param {string} storeName Name of the store for which to get copy info.\r\n * @returns {Object} The file details, e.g., name, size, key, etc., specific to the copy saved in this store.\r\n */\r\nFS.File.prototype.getCopyInfo = function(storeName) {\r\n  var self = this;\r\n  // Make sure we use the updated file record\r\n  self.getFileRecord();\r\n  return (self.copies && self.copies[storeName]) || null;\r\n};\r\n\r\n/**\r\n * @method FS.File.prototype._getInfo\r\n * @private\r\n * @param {String} [storeName] Name of the store for which to get file info. Omit for original file details.\r\n * @param {Object} [options]\r\n * @param {Boolean} [options.updateFileRecordFirst=false] Update this instance with data from the DB first?\r\n * @returns {Object} The file details, e.g., name, size, key, etc. If not found, returns an empty object.\r\n */\r\nFS.File.prototype._getInfo = function(storeName, options) {\r\n  var self = this;\r\n  options = options || {};\r\n\r\n  if (options.updateFileRecordFirst) {\r\n    // Make sure we use the updated file record\r\n    self.getFileRecord();\r\n  }\r\n\r\n  if (storeName) {\r\n    return (self.copies && self.copies[storeName]) || {};\r\n  } else {\r\n    return self.original || {};\r\n  }\r\n};\r\n\r\n/**\r\n * @method FS.File.prototype._setInfo\r\n * @private\r\n * @param {String} storeName - Name of the store for which to set file info. Non-string will set original file details.\r\n * @param {String} property - Property to set\r\n * @param {String} value - New value for property\r\n * @param {Boolean} save - Should the new value be saved to the DB, too, or just set in the FS.File properties?\r\n * @returns {undefined}\r\n */\r\nFS.File.prototype._setInfo = function(storeName, property, value, save) {\r\n  var self = this;\r\n  if (typeof storeName === \"string\") {\r\n    self.copies = self.copies || {};\r\n    self.copies[storeName] = self.copies[storeName] || {};\r\n    self.copies[storeName][property] = value;\r\n    save && self._saveChanges(storeName);\r\n  } else {\r\n    self.original = self.original || {};\r\n    self.original[property] = value;\r\n    save && self._saveChanges(\"_original\");\r\n  }\r\n};\r\n\r\n/**\r\n * @method FS.File.prototype.name\r\n * @public\r\n * @param {String|null} [value] - If setting the name, specify the new name as the first argument. Otherwise the options argument should be first.\r\n * @param {Object} [options]\r\n * @param {Object} [options.store=none,original] - Get or set the name of the version of the file that was saved in this store. Default is the original file name.\r\n * @param {Boolean} [options.updateFileRecordFirst=false] Update this instance with data from the DB first? Applies to getter usage only.\r\n * @param {Boolean} [options.save=true] Save change to database? Applies to setter usage only.\r\n * @returns {String|undefined} If setting, returns `undefined`. If getting, returns the file name.\r\n */\r\nFS.File.prototype.name = function(value, options) {\r\n  var self = this;\r\n\r\n  if (!options && ((typeof value === \"object\" && value !== null) || typeof value === \"undefined\")) {\r\n    // GET\r\n    options = value || {};\r\n    options = options.hash || options; // allow use as UI helper\r\n    return self._getInfo(options.store, options).name;\r\n  } else {\r\n    // SET\r\n    options = options || {};\r\n    return self._setInfo(options.store, 'name', value, typeof options.save === \"boolean\" ? options.save : true);\r\n  }\r\n};\r\n\r\n/**\r\n * @method FS.File.prototype.extension\r\n * @public\r\n * @param {String|null} [value] - If setting the extension, specify the new extension (without period) as the first argument. Otherwise the options argument should be first.\r\n * @param {Object} [options]\r\n * @param {Object} [options.store=none,original] - Get or set the extension of the version of the file that was saved in this store. Default is the original file extension.\r\n * @param {Boolean} [options.updateFileRecordFirst=false] Update this instance with data from the DB first? Applies to getter usage only.\r\n * @param {Boolean} [options.save=true] Save change to database? Applies to setter usage only.\r\n * @returns {String|undefined} If setting, returns `undefined`. If getting, returns the file extension or an empty string if there isn't one.\r\n */\r\nFS.File.prototype.extension = function(value, options) {\r\n  var self = this;\r\n\r\n  if (!options && ((typeof value === \"object\" && value !== null) || typeof value === \"undefined\")) {\r\n    // GET\r\n    options = value || {};\r\n    return FS.Utility.getFileExtension(self.name(options) || '');\r\n  } else {\r\n    // SET\r\n    options = options || {};\r\n    var newName = FS.Utility.setFileExtension(self.name(options) || '', value);\r\n    return self._setInfo(options.store, 'name', newName, typeof options.save === \"boolean\" ? options.save : true);\r\n  }\r\n};\r\n\r\n/**\r\n * @method FS.File.prototype.size\r\n * @public\r\n * @param {Number} [value] - If setting the size, specify the new size in bytes as the first argument. Otherwise the options argument should be first.\r\n * @param {Object} [options]\r\n * @param {Object} [options.store=none,original] - Get or set the size of the version of the file that was saved in this store. Default is the original file size.\r\n * @param {Boolean} [options.updateFileRecordFirst=false] Update this instance with data from the DB first? Applies to getter usage only.\r\n * @param {Boolean} [options.save=true] Save change to database? Applies to setter usage only.\r\n * @returns {Number|undefined} If setting, returns `undefined`. If getting, returns the file size.\r\n */\r\nFS.File.prototype.size = function(value, options) {\r\n  var self = this;\r\n\r\n  if (!options && ((typeof value === \"object\" && value !== null) || typeof value === \"undefined\")) {\r\n    // GET\r\n    options = value || {};\r\n    options = options.hash || options; // allow use as UI helper\r\n    return self._getInfo(options.store, options).size;\r\n  } else {\r\n    // SET\r\n    options = options || {};\r\n    return self._setInfo(options.store, 'size', value, typeof options.save === \"boolean\" ? options.save : true);\r\n  }\r\n};\r\n\r\n/**\r\n * @method FS.File.prototype.type\r\n * @public\r\n * @param {String} [value] - If setting the type, specify the new type as the first argument. Otherwise the options argument should be first.\r\n * @param {Object} [options]\r\n * @param {Object} [options.store=none,original] - Get or set the type of the version of the file that was saved in this store. Default is the original file type.\r\n * @param {Boolean} [options.updateFileRecordFirst=false] Update this instance with data from the DB first? Applies to getter usage only.\r\n * @param {Boolean} [options.save=true] Save change to database? Applies to setter usage only.\r\n * @returns {String|undefined} If setting, returns `undefined`. If getting, returns the file type.\r\n */\r\nFS.File.prototype.type = function(value, options) {\r\n  var self = this;\r\n\r\n  if (!options && ((typeof value === \"object\" && value !== null) || typeof value === \"undefined\")) {\r\n    // GET\r\n    options = value || {};\r\n    options = options.hash || options; // allow use as UI helper\r\n    return self._getInfo(options.store, options).type;\r\n  } else {\r\n    // SET\r\n    options = options || {};\r\n    return self._setInfo(options.store, 'type', value, typeof options.save === \"boolean\" ? options.save : true);\r\n  }\r\n};\r\n\r\n/**\r\n * @method FS.File.prototype.updatedAt\r\n * @public\r\n * @param {String} [value] - If setting updatedAt, specify the new date as the first argument. Otherwise the options argument should be first.\r\n * @param {Object} [options]\r\n * @param {Object} [options.store=none,original] - Get or set the last updated date for the version of the file that was saved in this store. Default is the original last updated date.\r\n * @param {Boolean} [options.updateFileRecordFirst=false] Update this instance with data from the DB first? Applies to getter usage only.\r\n * @param {Boolean} [options.save=true] Save change to database? Applies to setter usage only.\r\n * @returns {String|undefined} If setting, returns `undefined`. If getting, returns the file's last updated date.\r\n */\r\nFS.File.prototype.updatedAt = function(value, options) {\r\n  var self = this;\r\n\r\n  if (!options && ((typeof value === \"object\" && value !== null && !(value instanceof Date)) || typeof value === \"undefined\")) {\r\n    // GET\r\n    options = value || {};\r\n    options = options.hash || options; // allow use as UI helper\r\n    return self._getInfo(options.store, options).updatedAt;\r\n  } else {\r\n    // SET\r\n    options = options || {};\r\n    return self._setInfo(options.store, 'updatedAt', value, typeof options.save === \"boolean\" ? options.save : true);\r\n  }\r\n};\r\n\r\n/**\r\n * @method FS.File.onStoredCallback\r\n * @summary Calls callback when the file is fully stored to the specify storeName\r\n * @public\r\n * @param {String} [storeName] - The name of the file store we want to get called when stored.\r\n * @param {function} [callback]\r\n */\r\nFS.File.prototype.onStoredCallback = function (storeName, callback) {\r\n  // Check file is not already stored\r\n  if (this.hasStored(storeName)) {\r\n    callback();\r\n    return;\r\n  }\r\n  if (Meteor.isServer) {\r\n    // Listen to file stored events\r\n    // TODO Require thinking whether it is better to use observer for case of using multiple application instances, Ask for same image url while upload is being done.\r\n    this.on('stored', function (newStoreName) {\r\n      // If stored is completed to the specified store call callback\r\n      if (storeName === newStoreName) {\r\n        // Remove the specified file stored listener\r\n        this.removeListener('stored', arguments.callee);\r\n        callback();\r\n      }\r\n    }.bind(this)\r\n    );\r\n  } else {\r\n    var fileId = this._id,\r\n        collectionName = this.collectionName;\r\n    // Wait for file to be fully uploaded\r\n    Tracker.autorun(function (c) {\r\n      Meteor.call('_cfs_returnWhenStored', collectionName, fileId, storeName, function (error, result) {\r\n        if (result && result === true) {\r\n          c.stop();\r\n          callback();\r\n        } else {\r\n          Meteor.setTimeout(function () {\r\n            c.invalidate();\r\n          }, 100);\r\n        }\r\n      });\r\n    });\r\n  }\r\n};\r\n\r\n/**\r\n * @method FS.File.onStored\r\n * @summary Function that returns when the file is fully stored to the specify storeName\r\n * @public\r\n * @param {String} storeName - The name of the file store we want to get called when stored.\r\n *\r\n * Function that returns when the file is fully stored to the specify storeName.\r\n *\r\n * For example needed if wanted to save the direct link to a file on s3 when fully uploaded.\r\n */\r\nFS.File.prototype.onStored = function (arguments) {\r\n  var onStoredSync = Meteor.wrapAsync(this.onStoredCallback);\r\n  return onStoredSync.call(this, arguments);\r\n};\r\n\r\nfunction isBasicObject(obj) {\r\n  return (obj === Object(obj) && Object.getPrototypeOf(obj) === Object.prototype);\r\n}\r\n\r\n// getPrototypeOf polyfill\r\nif (typeof Object.getPrototypeOf !== \"function\") {\r\n  if (typeof \"\".__proto__ === \"object\") {\r\n    Object.getPrototypeOf = function(object) {\r\n      return object.__proto__;\r\n    };\r\n  } else {\r\n    Object.getPrototypeOf = function(object) {\r\n      // May break if the constructor has been tampered with\r\n      return object.constructor.prototype;\r\n    };\r\n  }\r\n}\r\n\r\n\r\n","/**\r\n * Notes a details about a storage adapter failure within the file record\r\n * @param {string} storeName\r\n * @param {number} maxTries\r\n * @return {undefined}\r\n * @todo deprecate this\r\n */\r\nFS.File.prototype.logCopyFailure = function(storeName, maxTries) {\r\n  var self = this;\r\n\r\n  // hasStored will update from the fileRecord\r\n  if (self.hasStored(storeName)) {\r\n    throw new Error(\"logCopyFailure: invalid storeName\");\r\n  }\r\n\r\n  // Make sure we have a temporary file saved since we will be\r\n  // trying the save again.\r\n  FS.TempStore.ensureForFile(self);\r\n\r\n  var now = new Date();\r\n  var currentCount = (self.failures && self.failures.copies && self.failures.copies[storeName] && typeof self.failures.copies[storeName].count === \"number\") ? self.failures.copies[storeName].count : 0;\r\n  maxTries = maxTries || 5;\r\n\r\n  var modifier = {};\r\n  modifier.$set = {};\r\n  modifier.$set['failures.copies.' + storeName + '.lastAttempt'] = now;\r\n  if (currentCount === 0) {\r\n    modifier.$set['failures.copies.' + storeName + '.firstAttempt'] = now;\r\n  }\r\n  modifier.$set['failures.copies.' + storeName + '.count'] = currentCount + 1;\r\n  modifier.$set['failures.copies.' + storeName + '.doneTrying'] = (currentCount + 1 >= maxTries);\r\n  self.update(modifier);\r\n};\r\n\r\n/**\r\n * Has this store permanently failed?\r\n * @param {String} storeName The name of the store\r\n * @return {boolean} Has this store failed permanently?\r\n * @todo deprecate this\r\n */\r\nFS.File.prototype.failedPermanently = function(storeName) {\r\n  var self = this;\r\n  return !!(self.failures &&\r\n            self.failures.copies &&\r\n            self.failures.copies[storeName] &&\r\n            self.failures.copies[storeName].doneTrying);\r\n};\r\n\r\n/**\r\n * @method FS.File.prototype.createReadStream\r\n * @public\r\n * @param {String} [storeName]\r\n * @returns {stream.Readable} Readable NodeJS stream\r\n *\r\n * Returns a readable stream. Where the stream reads from depends on the FS.File instance and whether you pass a store name.\r\n *\r\n * * If you pass a `storeName`, a readable stream for the file data saved in that store is returned.\r\n * * If you don't pass a `storeName` and data is attached to the FS.File instance (on `data` property, which must be a DataMan instance), then a readable stream for the attached data is returned.\r\n * * If you don't pass a `storeName` and there is no data attached to the FS.File instance, a readable stream for the file data currently in the temporary store (`FS.TempStore`) is returned.\r\n *\r\n */\r\nFS.File.prototype.createReadStream = function(storeName) {\r\n  var self = this;\r\n\r\n  // If we dont have a store name but got Buffer data?\r\n  if (!storeName && self.data) {\r\n    FS.debug && console.log(\"fileObj.createReadStream creating read stream for attached data\");\r\n    // Stream from attached data if present\r\n    return self.data.createReadStream();\r\n  } else if (!storeName && FS.TempStore && FS.TempStore.exists(self)) {\r\n    FS.debug && console.log(\"fileObj.createReadStream creating read stream for temp store\");\r\n    // Stream from temp store - its a bit slower than regular streams?\r\n    return FS.TempStore.createReadStream(self);\r\n  } else {\r\n    // Stream from the store using storage adapter\r\n    if (self.isMounted()) {\r\n      var storage = self.collection.storesLookup[storeName] || self.collection.primaryStore;\r\n      FS.debug && console.log(\"fileObj.createReadStream creating read stream for store\", storage.name);\r\n      // return stream\r\n      return storage.adapter.createReadStream(self);\r\n    } else {\r\n      throw new Meteor.Error('File not mounted');\r\n    }\r\n\r\n  }\r\n};\r\n\r\n/**\r\n * @method FS.File.prototype.createWriteStream\r\n * @public\r\n * @param {String} [storeName]\r\n * @returns {stream.Writeable} Writeable NodeJS stream\r\n *\r\n * Returns a writeable stream. Where the stream writes to depends on whether you pass in a store name.\r\n *\r\n * * If you pass a `storeName`, a writeable stream for (over)writing the file data in that store is returned.\r\n * * If you don't pass a `storeName`, a writeable stream for writing to the temp store for this file is returned.\r\n *\r\n */\r\nFS.File.prototype.createWriteStream = function(storeName) {\r\n  var self = this;\r\n\r\n  // We have to have a mounted file in order for this to work\r\n  if (self.isMounted()) {\r\n    if (!storeName && FS.TempStore && FS.FileWorker) {\r\n      // If we have worker installed - we pass the file to FS.TempStore\r\n      // We dont need the storeName since all stores will be generated from\r\n      // TempStore.\r\n      // This should trigger FS.FileWorker at some point?\r\n      FS.TempStore.createWriteStream(self);\r\n    } else {\r\n      // Stream directly to the store using storage adapter\r\n      var storage = self.collection.storesLookup[storeName] || self.collection.primaryStore;\r\n      return storage.adapter.createWriteStream(self);\r\n    }\r\n  } else {\r\n    throw new Meteor.Error('File not mounted');\r\n  }\r\n};\r\n\r\n/**\r\n * @method FS.File.prototype.copy Makes a copy of the file and underlying data in all stores.\r\n * @public\r\n * @returns {FS.File} The new FS.File instance\r\n */\r\nFS.File.prototype.copy = function() {\r\n  var self = this;\r\n\r\n  if (!self.isMounted()) {\r\n    throw new Error(\"Cannot copy a file that is not associated with a collection\");\r\n  }\r\n\r\n  // Get the file record\r\n  var fileRecord = self.collection.files.findOne({_id: self._id}, {transform: null}) || {};\r\n\r\n  // Remove _id and copy keys from the file record\r\n  delete fileRecord._id;\r\n\r\n  // Insert directly; we don't have access to \"original\" in this case\r\n  var newId = self.collection.files.insert(fileRecord);\r\n\r\n  var newFile = self.collection.findOne(newId);\r\n\r\n  // Copy underlying files in the stores\r\n  var mod, oldKey;\r\n  for (var name in newFile.copies) {\r\n    if (newFile.copies.hasOwnProperty(name)) {\r\n      oldKey = newFile.copies[name].key;\r\n      if (oldKey) {\r\n        // We need to ask the adapter for the true oldKey because\r\n        // right now gridfs does some extra stuff.\r\n        // TODO GridFS should probably set the full key object\r\n        // (with _id and filename) into `copies.key`\r\n        // so that copies.key can be passed directly to\r\n        // createReadStreamForFileKey\r\n        var sourceFileStorage = self.collection.storesLookup[name];\r\n        if (!sourceFileStorage) {\r\n          throw new Error(name + \" is not a valid store name\");\r\n        }\r\n        oldKey = sourceFileStorage.adapter.fileKey(self);\r\n        // delete so that new fileKey will be generated in copyStoreData\r\n        delete newFile.copies[name].key;\r\n        mod = mod || {};\r\n        mod[\"copies.\" + name + \".key\"] = copyStoreData(newFile, name, oldKey);\r\n      }\r\n    }\r\n  }\r\n  // Update keys in the filerecord\r\n  if (mod) {\r\n    newFile.update({$set: mod});\r\n  }\r\n\r\n  return newFile;\r\n};\r\n\r\nMeteor.methods({\r\n  // Does a HEAD request to URL to get the type, updatedAt,\r\n  // and size prior to actually downloading the data.\r\n  // That way we can do filter checks without actually downloading.\r\n  '_cfs_getUrlInfo': function (url, options) {\r\n    check(url, String);\r\n    check(options, Object);\r\n\r\n    this.unblock();\r\n\r\n    var response = HTTP.call(\"HEAD\", url, options);\r\n    var headers = response.headers;\r\n    var result = {};\r\n\r\n    if (headers['content-type']) {\r\n      result.type = headers['content-type'];\r\n    }\r\n\r\n    if (headers['content-length']) {\r\n      result.size = +headers['content-length'];\r\n    }\r\n\r\n    if (headers['last-modified']) {\r\n      result.updatedAt = new Date(headers['last-modified']);\r\n    }\r\n\r\n    return result;\r\n  },\r\n  // Helper function that checks whether given fileId from collectionName\r\n  //  Is fully uploaded to specify storeName.\r\n  '_cfs_returnWhenStored' : function (collectionName, fileId, storeName) {\r\n    check(collectionName, String);\r\n    check(fileId, String);\r\n    check(storeName, String);\r\n\r\n    var collection = FS._collections[collectionName];\r\n    if (!collection) {\r\n      return Meteor.Error('_cfs_returnWhenStored: FSCollection name not exists');\r\n    }\r\n\r\n    var file = collection.findOne({_id: fileId});\r\n    if (!file) {\r\n      return Meteor.Error('_cfs_returnWhenStored: FSFile not exists');\r\n    }\r\n    return file.hasStored(storeName);\r\n  }\r\n});\r\n\r\n// TODO maybe this should be in cfs-storage-adapter\r\nfunction _copyStoreData(fileObj, storeName, sourceKey, callback) {\r\n  if (!fileObj.isMounted()) {\r\n    throw new Error(\"Cannot copy store data for a file that is not associated with a collection\");\r\n  }\r\n\r\n  var storage = fileObj.collection.storesLookup[storeName];\r\n  if (!storage) {\r\n    throw new Error(storeName + \" is not a valid store name\");\r\n  }\r\n\r\n  // We want to prevent beforeWrite and transformWrite from running, so\r\n  // we interact directly with the store.\r\n  var destinationKey = storage.adapter.fileKey(fileObj);\r\n  var readStream = storage.adapter.createReadStreamForFileKey(sourceKey);\r\n  var writeStream = storage.adapter.createWriteStreamForFileKey(destinationKey);\r\n\r\n  writeStream.once('stored', function(result) {\r\n    callback(null, result.fileKey);\r\n  });\r\n\r\n  writeStream.once('error', function(error) {\r\n    callback(error);\r\n  });\r\n\r\n  readStream.pipe(writeStream);\r\n}\r\nvar copyStoreData = Meteor.wrapAsync(_copyStoreData);\r\n\r\n/**\r\n * @method FS.File.prototype.copyData Copies the content of a store directly into another store.\r\n * @public\r\n * @param {string} sourceStoreName\r\n * @param {string} targetStoreName\r\n * @param {boolean=} move\r\n */\r\nFS.File.prototype.copyData = function(sourceStoreName, targetStoreName, move){\r\n\r\n  move = !!move;\r\n  /**\r\n   * @type {Object.<string,*>}\r\n   */\r\n  var sourceStoreValues = this.copies[sourceStoreName];\r\n  /**\r\n   * @type {string}\r\n   */\r\n  var copyKey = cloneDataToStore(this, sourceStoreName, targetStoreName, move);\r\n  /**\r\n   * @type {Object.<string,*>}\r\n   */\r\n  var targetStoreValues = {};\r\n  for (var v in sourceStoreValues) {\r\n    if (sourceStoreValues.hasOwnProperty(v)) {\r\n      targetStoreValues[v] = sourceStoreValues[v]\r\n    }\r\n  }\r\n  targetStoreValues.key = copyKey;\r\n  targetStoreValues.createdAt = new Date();\r\n  targetStoreValues.updatedAt = new Date();\r\n  /**\r\n   *\r\n   * @type {modifier}\r\n   */\r\n  var modifier = {};\r\n  modifier.$set = {};\r\n  modifier.$set[\"copies.\"+targetStoreName] = targetStoreValues;\r\n  if(move){\r\n    modifier.$unset = {};\r\n    modifier.$unset[\"copies.\"+sourceStoreName] = \"\";\r\n  }\r\n  this.update(modifier);\r\n};\r\n/**\r\n * @method FS.File.prototype.moveData Moves the content of a store directly into another store.\r\n * @public\r\n * @param {string} sourceStoreName\r\n * @param {string} targetStoreName\r\n */\r\nFS.File.prototype.moveData = function(sourceStoreName, targetStoreName){\r\n  this.copyData(sourceStoreName, targetStoreName, true);\r\n};\r\n// TODO maybe this should be in cfs-storage-adapter\r\n/**\r\n *\r\n * @param {FS.File} fileObj\r\n * @param {string} sourceStoreName\r\n * @param {string} targetStoreName\r\n * @param {boolean} move\r\n * @param callback\r\n * @private\r\n */\r\nfunction _copyDataFromStoreToStore(fileObj, sourceStoreName, targetStoreName, move, callback) {\r\n  if (!fileObj.isMounted()) {\r\n    throw new Error(\"Cannot copy store data for a file that is not associated with a collection\");\r\n  }\r\n  /**\r\n   * @type {FS.StorageAdapter}\r\n   */\r\n  var sourceStorage = fileObj.collection.storesLookup[sourceStoreName];\r\n  /**\r\n   * @type {FS.StorageAdapter}\r\n   */\r\n  var targetStorage = fileObj.collection.storesLookup[targetStoreName];\r\n\r\n  if (!sourceStorage) {\r\n    throw new Error(sourceStoreName + \" is not a valid store name\");\r\n  }\r\n  if (!targetStorage) {\r\n    throw new Error(targetStorage + \" is not a valid store name\");\r\n  }\r\n\r\n  // We want to prevent beforeWrite and transformWrite from running, so\r\n  // we interact directly with the store.\r\n  var sourceKey = sourceStorage.adapter.fileKey(fileObj);\r\n  var targetKey = targetStorage.adapter.fileKey(fileObj);\r\n  var readStream = sourceStorage.adapter.createReadStreamForFileKey(sourceKey);\r\n  var writeStream = targetStorage.adapter.createWriteStreamForFileKey(targetKey);\r\n\r\n\r\n  writeStream.safeOnce('stored', function(result) {\r\n    if(move && sourceStorage.adapter.remove(fileObj)===false){\r\n      callback(\"Copied to store:\" + targetStoreName\r\n      + \" with fileKey: \"\r\n      + result.fileKey\r\n      + \", but could not delete from source store: \"\r\n      + sourceStoreName);\r\n    }else{\r\n      callback(null, result.fileKey);\r\n    }\r\n  });\r\n\r\n  writeStream.once('error', function(error) {\r\n    callback(error);\r\n  });\r\n\r\n  readStream.pipe(writeStream);\r\n}\r\nvar cloneDataToStore = Meteor.wrapAsync(_copyDataFromStoreToStore);\r\n"]}