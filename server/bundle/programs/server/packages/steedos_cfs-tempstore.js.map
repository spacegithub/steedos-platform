{"version":3,"sources":["meteor://ðŸ’»app/packages/steedos:cfs-tempstore/checkNpm.js","meteor://ðŸ’»app/packages/steedos:cfs-tempstore/tempStore.js"],"names":["checkNpmVersions","module","link","v","EventEmitter","require","CombinedStream","FS","TempStore","tracker","Tracker","Mongo","Collection","Storage","mountStorage","Package","Store","GridFS","internal","FileSystem","path","Creator","steedosStorageDir","Error","debug","console","log","typeName","mountFile","fileObj","name","isMounted","on","chunkNum","count","total","result","_chunkPath","n","_fileReference","chunk","existing","findOne","fileId","_id","collectionName","tempFileObj","File","original","copies","_tempstore","key","keys","adapter","fileKey","exists","listParts","fsTempStoreListParts","self","warn","removeFile","fsTempStoreRemoveFile","emit","chunkInfo","Utility","each","remove","noop","removeAll","fsTempStoreRemoveAll","find","forEach","createWriteStream","options","selector","chunkSum","upsert","$setOnInsert","isOnePart","isMultiPart","isStoreSync","writeStream","safeOn","setObj","update","$set","chunkCount","size","modifier","$unset","chunkSize","uploadedAt","Date","synchronizedAt","eventName","error","createReadStream","totalChunks","getNextStreamFunc","Meteor","bindEnvironment","next","chunkReadStream","combinedStream","create","currentChunk","append"],"mappings":"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","file":"/packages/steedos_cfs-tempstore.js","sourcesContent":["import { checkNpmVersions } from 'meteor/tmeasday:check-npm-versions';\ncheckNpmVersions({\n\t'combined-stream': '0.0.4'\n}, 'steedos:cfs-tempstore');","// ##Temporary Storage\n//\n// Temporary storage is used for chunked uploads until all chunks are received\n// and all copies have been made or given up. In some cases, the original file\n// is stored only in temporary storage (for example, if all copies do some\n// manipulation in beforeSave). This is why we use the temporary file as the\n// basis for each saved copy, and then remove it after all copies are saved.\n//\n// Every chunk is saved as an individual temporary file. This is safer than\n// attempting to write multiple incoming chunks to different positions in a\n// single temporary file, which can lead to write conflicts.\n//\n// Using temp files also allows us to easily resume uploads, even if the server\n// restarts, and to keep the working memory clear.\n\n// The FS.TempStore emits events that others are able to listen to\nvar EventEmitter = require('events').EventEmitter;\n\n// We have a special stream concating all chunk files into one readable stream\nvar CombinedStream = require('combined-stream');\n\n/** @namespace FS.TempStore\n * @property FS.TempStore\n * @type {object}\n * @public\n * *it's an event emitter*\n */\nFS.TempStore = new EventEmitter();\n\n// Create a tracker collection for keeping track of all chunks for any files that are currently in the temp store\nvar tracker = FS.TempStore.Tracker = new Mongo.Collection('cfs._tempstore.chunks');\n\n/**\n * @property FS.TempStore.Storage\n * @type {StorageAdapter}\n * @namespace FS.TempStore\n * @private\n * This property is set to either `FS.Store.FileSystem` or `FS.Store.GridFS`\n *\n * __When and why:__\n * We normally default to `cfs-filesystem` unless its not installed. *(we default to gridfs if installed)*\n * But if `cfs-gridfs` and `cfs-worker` is installed we default to `cfs-gridfs`\n *\n * If `cfs-gridfs` and `cfs-filesystem` is not installed we log a warning.\n * the user can set `FS.TempStore.Storage` them selfs eg.:\n * ```js\n *   // Its important to set `internal: true` this lets the SA know that we\n *   // are using this internally and it will give us direct SA api\n *   FS.TempStore.Storage = new FS.Store.GridFS('_tempstore', { internal: true });\n * ```\n *\n * > Note: This is considered as `advanced` use, its not a common pattern.\n */\nFS.TempStore.Storage = null;\n\n// We will not mount a storage adapter until needed. This allows us to check for the\n// existance of FS.FileWorker, which is loaded after this package because it\n// depends on this package.\nfunction mountStorage() {\n\n  if (FS.TempStore.Storage) return;\n\n  // XXX: We could replace this test, testing the FS scope for grifFS etc.\n  // This is on the todo later when we get \"stable\"\n  if (Package[\"steedos:cfs-gridfs\"] && (Package[\"steedos:cfs-worker\"] || !Package[\"steedos:cfs-filesystem\"])) {\n    // If the file worker is installed we would prefer to use the gridfs sa\n    // for scalability. We also default to gridfs if filesystem is not found\n\n    // Use the gridfs\n    FS.TempStore.Storage = new FS.Store.GridFS('_tempstore', { internal: true });\n  } else if (Package[\"steedos:cfs-filesystem\"]) {\n\n    // use the Filesystem\n    FS.TempStore.Storage = new FS.Store.FileSystem('_tempstore', { path: Creator.steedosStorageDir+'/_tempstore', internal: true });\n  } else {\n    throw new Error('FS.TempStore.Storage is not set: Install steedos:cfs-filesystem or steedos:cfs-gridfs or set it manually');\n  }\n\n  FS.debug && console.log('TempStore is mounted on', FS.TempStore.Storage.typeName);\n}\n\nfunction mountFile(fileObj, name) {\n  if (!fileObj.isMounted()) {\n    throw new Error(name + ' cannot work with unmounted file');\n  }\n}\n\n// We update the fileObj on progress\nFS.TempStore.on('progress', function(fileObj, chunkNum, count, total, result) {\n  FS.debug && console.log('TempStore progress: Received ' + count + ' of ' + total + ' chunks for ' + fileObj.name());\n});\n\n// XXX: TODO\n// FS.TempStore.on('stored', function(fileObj, chunkCount, result) {\n//   // This should work if we pass on result from the SA on stored event...\n//   fileObj.update({ $set: { chunkSum: 1, chunkCount: chunkCount, size: result.size } });\n// });\n\n// Stream implementation\n\n/**\n * @method _chunkPath\n * @private\n * @param {Number} [n] Chunk number\n * @returns {String} Chunk naming convention\n */\n_chunkPath = function(n) {\n  return (n || 0) + '.chunk';\n};\n\n/**\n * @method _fileReference\n * @param {FS.File} fileObj\n * @param {Number} chunk\n * @private\n * @returns {String} Generated SA specific fileKey for the chunk\n *\n * Note: Calling function should call mountStorage() first, and\n * make sure that fileObj is mounted.\n */\n_fileReference = function(fileObj, chunk, existing) {\n  // Maybe it's a chunk we've already saved\n  existing = existing || tracker.findOne({fileId: fileObj._id, collectionName: fileObj.collectionName});\n\n  // Make a temporary fileObj just for fileKey generation\n  var tempFileObj = new FS.File({\n    collectionName: fileObj.collectionName,\n    _id: fileObj._id,\n    original: {\n      name: _chunkPath(chunk)\n    },\n    copies: {\n      _tempstore: {\n        key: existing && existing.keys[chunk]\n      }\n    }\n  });\n\n  // Return a fitting fileKey SA specific\n  return FS.TempStore.Storage.adapter.fileKey(tempFileObj);\n};\n\n/**\n * @method FS.TempStore.exists\n * @param {FS.File} File object\n * @returns {Boolean} Is this file, or parts of it, currently stored in the TempStore\n */\nFS.TempStore.exists = function(fileObj) {\n  var existing = tracker.findOne({fileId: fileObj._id, collectionName: fileObj.collectionName});\n  return !!existing;\n};\n\n/**\n * @method FS.TempStore.listParts\n * @param {FS.File} fileObj\n * @returns {Object} of parts already stored\n * @todo This is not yet implemented, milestone 1.1.0\n */\nFS.TempStore.listParts = function fsTempStoreListParts(fileObj) {\n  var self = this;\n  console.warn('This function is not correctly implemented using SA in TempStore');\n  //XXX This function might be necessary for resume. Not currently supported.\n};\n\n/**\n * @method FS.TempStore.removeFile\n * @public\n * @param {FS.File} fileObj\n * This function removes the file from tempstorage - it cares not if file is\n * already removed or not found, goal is reached anyway.\n */\nFS.TempStore.removeFile = function fsTempStoreRemoveFile(fileObj) {\n  var self = this;\n\n  // Ensure that we have a storage adapter mounted; if not, throw an error.\n  mountStorage();\n\n  // If fileObj is not mounted or can't be, throw an error\n  mountFile(fileObj, 'FS.TempStore.removeFile');\n\n  // Emit event\n  self.emit('remove', fileObj);\n\n  var chunkInfo = tracker.findOne({\n    fileId: fileObj._id,\n    collectionName: fileObj.collectionName\n  });\n\n  if (chunkInfo) {\n\n    // Unlink each file\n    FS.Utility.each(chunkInfo.keys || {}, function (key, chunk) {\n      var fileKey = _fileReference(fileObj, chunk, chunkInfo);\n      FS.TempStore.Storage.adapter.remove(fileKey, FS.Utility.noop);\n    });\n\n    // Remove fileObj from tracker collection, too\n    tracker.remove({_id: chunkInfo._id});\n\n  }\n};\n\n/**\n * @method FS.TempStore.removeAll\n * @public\n * This function removes all files from tempstorage - it cares not if file is\n * already removed or not found, goal is reached anyway.\n */\nFS.TempStore.removeAll = function fsTempStoreRemoveAll() {\n  var self = this;\n\n  // Ensure that we have a storage adapter mounted; if not, throw an error.\n  mountStorage();\n\n  tracker.find().forEach(function (chunkInfo) {\n    // Unlink each file\n    FS.Utility.each(chunkInfo.keys || {}, function (key, chunk) {\n      var fileKey = _fileReference({_id: chunkInfo.fileId, collectionName: chunkInfo.collectionName}, chunk, chunkInfo);\n      FS.TempStore.Storage.adapter.remove(fileKey, FS.Utility.noop);\n    });\n\n    // Remove from tracker collection, too\n    tracker.remove({_id: chunkInfo._id});\n  });\n};\n\n/**\n * @method FS.TempStore.createWriteStream\n * @public\n * @param {FS.File} fileObj File to store in temporary storage\n * @param {Number | String} [options]\n * @returns {Stream} Writeable stream\n *\n * `options` of different types mean differnt things:\n * * `undefined` We store the file in one part\n * *(Normal server-side api usage)*\n * * `Number` the number is the part number total\n * *(multipart uploads will use this api)*\n * * `String` the string is the name of the `store` that wants to store file data\n * *(stores that want to sync their data to the rest of the files stores will use this)*\n *\n * > Note: fileObj must be mounted on a `FS.Collection`, it makes no sense to store otherwise\n */\nFS.TempStore.createWriteStream = function(fileObj, options) {\n  var self = this;\n\n  // Ensure that we have a storage adapter mounted; if not, throw an error.\n  mountStorage();\n\n  // If fileObj is not mounted or can't be, throw an error\n  mountFile(fileObj, 'FS.TempStore.createWriteStream');\n\n  // Cache the selector for use multiple times below\n  var selector = {fileId: fileObj._id, collectionName: fileObj.collectionName};\n\n  // TODO, should pass in chunkSum so we don't need to use FS.File for it\n  var chunkSum = fileObj.chunkSum || 1;\n\n  // Add fileObj to tracker collection\n  tracker.upsert(selector, {$setOnInsert: {keys: {}}});\n\n  // Determine how we're using the writeStream\n  var isOnePart = false, isMultiPart = false, isStoreSync = false, chunkNum = 0;\n  if (options === +options) {\n    isMultiPart = true;\n    chunkNum = options;\n  } else if (options === ''+options) {\n    isStoreSync = true;\n  } else {\n    isOnePart = true;\n  }\n\n  // XXX: it should be possible for a store to sync by storing data into the\n  // tempstore - this could be done nicely by setting the store name as string\n  // in the chunk variable?\n  // This store name could be passed on the the fileworker via the uploaded\n  // event\n  // So the uploaded event can return:\n  // undefined - if data is stored into and should sync out to all storage adapters\n  // number - if a chunk has been uploaded\n  // string - if a storage adapter wants to sync its data to the other SA's\n\n  // Find a nice location for the chunk data\n  var fileKey = _fileReference(fileObj, chunkNum);\n\n  // Create the stream as Meteor safe stream\n  var writeStream = FS.TempStore.Storage.adapter.createWriteStream(fileKey);\n\n  // When the stream closes we update the chunkCount\n  writeStream.safeOn('stored', function(result) {\n    // Save key in tracker document\n    var setObj = {};\n    setObj['keys.' + chunkNum] = result.fileKey;\n    tracker.update(selector, {$set: setObj});\n\n    // Get updated chunkCount\n    var chunkCount = FS.Utility.size(tracker.findOne(selector).keys);\n\n    // Progress\n    self.emit('progress', fileObj, chunkNum, chunkCount, chunkSum, result);\n\n    // If upload is completed\n    if (chunkCount === chunkSum) {\n      // We no longer need the chunk info\n      var modifier = { $set: {}, $unset: {chunkCount: 1, chunkSum: 1, chunkSize: 1} };\n\n      // Check if the file has been uploaded before\n      if (typeof fileObj.uploadedAt === 'undefined') {\n        // We set the uploadedAt date\n        modifier.$set.uploadedAt = new Date();\n      } else {\n        // We have been uploaded so an event were file data is updated is\n        // called synchronizing - so this must be a synchronizedAt?\n        modifier.$set.synchronizedAt = new Date();\n      }\n\n      // Update the fileObject\n      fileObj.update(modifier);\n\n      // Fire ending events\n      var eventName = isStoreSync ? 'synchronized' : 'stored';\n      self.emit(eventName, fileObj, result);\n\n      // XXX is emitting \"ready\" necessary?\n      self.emit('ready', fileObj, chunkCount, result);\n    } else {\n      // Update the chunkCount on the fileObject\n      fileObj.update({ $set: {chunkCount: chunkCount} });\n    }\n  });\n\n  // Emit errors\n  writeStream.on('error', function (error) {\n    FS.debug && console.log('TempStore writeStream error:', error);\n    self.emit('error', error, fileObj);\n  });\n\n  return writeStream;\n};\n\n/**\n  * @method FS.TempStore.createReadStream\n  * @public\n  * @param {FS.File} fileObj The file to read\n  * @return {Stream} Returns readable stream\n  *\n  */\nFS.TempStore.createReadStream = function(fileObj) {\n  // Ensure that we have a storage adapter mounted; if not, throw an error.\n  mountStorage();\n\n  // If fileObj is not mounted or can't be, throw an error\n  mountFile(fileObj, 'FS.TempStore.createReadStream');\n\n  FS.debug && console.log('FS.TempStore creating read stream for ' + fileObj._id);\n\n  // Determine how many total chunks there are from the tracker collection\n  var chunkInfo = tracker.findOne({fileId: fileObj._id, collectionName: fileObj.collectionName}) || {};\n  var totalChunks = FS.Utility.size(chunkInfo.keys);\n\n  function getNextStreamFunc(chunk) {\n    return Meteor.bindEnvironment(function(next) {\n      var fileKey = _fileReference(fileObj, chunk);\n      var chunkReadStream = FS.TempStore.Storage.adapter.createReadStream(fileKey);\n      next(chunkReadStream);\n    }, function (error) {\n      throw error;\n    });\n  }\n\n  // Make a combined stream\n  var combinedStream = CombinedStream.create();\n\n  // Add each chunk stream to the combined stream when the previous chunk stream ends\n  var currentChunk = 0;\n  for (var chunk = 0; chunk < totalChunks; chunk++) {\n    combinedStream.append(getNextStreamFunc(chunk));\n  }\n\n  // Return the combined stream\n  return combinedStream;\n};\n"]}