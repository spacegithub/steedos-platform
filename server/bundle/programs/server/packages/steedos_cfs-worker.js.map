{"version":3,"sources":["meteor://ðŸ’»app/packages/steedos:cfs-worker/fileWorker.js"],"names":["FS","FileWorker","path","require","fs","observe","fsCollection","getReadyQuery","storeName","selector","uploadedAt","$exists","$ne","getDoneQuery","stores","$and","chunks","Utility","each","store","name","copyCond","$or","tempCond","push","saveCopy","fsFile","options","storage","StorageAdapter","Error","debug","console","log","TempStore","exists","temp_chunk","Tracker","findOne","fileId","_id","is_saveCopy","filepath","join","Creator","steedosStorageDir","keys","existsSync","r","update","$set","writeStream","adapter","createWriteStream","readStream","createReadStream","pipe"],"mappings":"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","file":"/packages/steedos_cfs-worker.js","sourcesContent":["//// TODO: Use power queue to handle throttling etc.\n//// Use observe to monitor changes and have it create tasks for the power queue\n//// to perform.\n\n/**\n * @public\n * @type Object\n */\nFS.FileWorker = {};\nvar path = require('path');\nvar fs = require('fs');\n\n/**\n * @method FS.FileWorker.observe\n * @public\n * @param {FS.Collection} fsCollection\n * @returns {undefined}\n *\n * Sets up observes on the fsCollection to store file copies and delete\n * temp files at the appropriate times.\n */\nFS.FileWorker.observe = function (fsCollection) {\n\n  // if (Meteor.settings.cfs && Meteor.settings.cfs.worker && Meteor.settings.cfs.worker.enabled) {\n  //   // Initiate observe for finding newly uploaded/added files that need to be stored\n  //   // per store.\n  //   FS.Utility.each(fsCollection.options.stores, function (store) {\n  //     var storeName = store.name;\n  //     fsCollection.files.find(getReadyQuery(storeName), {\n  //       fields: {\n  //         copies: 0\n  //       }\n  //     }).observe({\n  //       added: function (fsFile) {\n  //         // added will catch fresh files\n  //         FS.debug && console.log(\"FileWorker ADDED - calling saveCopy\", storeName, \"for\", fsFile._id);\n  //         saveCopy(fsFile, storeName);\n  //       },\n  //       changed: function (fsFile) {\n  //         // changed will catch failures and retry them\n  //         FS.debug && console.log(\"FileWorker CHANGED - calling saveCopy\", storeName, \"for\", fsFile._id);\n  //         saveCopy(fsFile, storeName);\n  //       }\n  //     });\n  //   });\n\n  //   // Initiate observe for finding files that have been stored so we can delete\n  //   // any temp files\n  //   fsCollection.files.find(getDoneQuery(fsCollection.options.stores)).observe({\n  //     added: function (fsFile) {\n  //       FS.debug && console.log(\"FileWorker ADDED - calling deleteChunks for\", fsFile._id);\n  //       FS.TempStore.removeFile(fsFile);\n  //     }\n  //   });\n  // }\n\n\n\n  // // Initiate observe for catching files that have been removed and\n  // // removing the data from all stores as well\n  // fsCollection.files.find().observe({\n  //   removed: function(fsFile) {\n  //     FS.debug && console.log('FileWorker REMOVED - removing all stored data for', fsFile._id);\n  //     //remove from temp store\n  //     FS.TempStore.removeFile(fsFile);\n  //     //delete from all stores\n  //     FS.Utility.each(fsCollection.options.stores, function(storage) {\n  //       try {\n  //         storage.adapter.remove(fsFile);\n  //       } catch (e) {\n  //         return\n  //       }\n  //     });\n  //   }\n  // });\n};\n\n/**\n *  @method getReadyQuery\n *  @private\n *  @param {string} storeName - The name of the store to observe\n *\n *  Returns a selector that will be used to identify files that\n *  have been uploaded but have not yet been stored to the\n *  specified store.\n *\n *  {\n *    uploadedAt: {$exists: true},\n *    'copies.storeName`: null,\n *    'failures.copies.storeName.doneTrying': {$ne: true}\n *  }\n */\nfunction getReadyQuery(storeName) {\n  var selector = {\n    uploadedAt: {\n      $exists: true\n    }\n  };\n  selector['copies.' + storeName] = null;\n  selector['failures.copies.' + storeName + '.doneTrying'] = {\n    $ne: true\n  };\n  return selector;\n}\n\n/**\n *  @method getDoneQuery\n *  @private\n *  @param {Array} stores - The stores array from the FS.Collection options\n *\n *  Returns a selector that will be used to identify files where all\n *  stores have successfully save or have failed the\n *  max number of times but still have chunks. The resulting selector\n *  should be something like this:\n *\n *  {\n *    $and: [\n *      {chunks: {$exists: true}},\n *      {\n *        $or: [\n *          {\n *            $and: [\n *              {\n *                'copies.storeName': {$ne: null}\n *              },\n *              {\n *                'copies.storeName': {$ne: false}\n *              }\n *            ]\n *          },\n *          {\n *            'failures.copies.storeName.doneTrying': true\n *          }\n *        ]\n *      },\n *      REPEATED FOR EACH STORE\n *    ]\n *  }\n *\n */\nfunction getDoneQuery(stores) {\n  var selector = {\n    $and: [{\n      chunks: {\n        $exists: true\n      }\n    }]\n  };\n\n  // Add conditions for all defined stores\n  FS.Utility.each(stores, function (store) {\n    var storeName = store.name;\n    var copyCond = {\n      $or: [{\n        $and: []\n      }]\n    };\n    var tempCond = {};\n    tempCond[\"copies.\" + storeName] = {\n      $ne: null\n    };\n    copyCond.$or[0].$and.push(tempCond);\n    tempCond = {};\n    tempCond[\"copies.\" + storeName] = {\n      $ne: false\n    };\n    copyCond.$or[0].$and.push(tempCond);\n    tempCond = {};\n    tempCond['failures.copies.' + storeName + '.doneTrying'] = true;\n    copyCond.$or.push(tempCond);\n    selector.$and.push(copyCond);\n  })\n\n  return selector;\n}\n\n/**\n * @method saveCopy\n * @private\n * @param {FS.File} fsFile\n * @param {string} storeName\n * @param {Object} options\n * @param {Boolean} [options.overwrite=false] - Force save to the specified store?\n * @returns {undefined}\n *\n * Saves to the specified store. If the\n * `overwrite` option is `true`, will save to the store even if we already\n * have, potentially overwriting any previously saved data. Synchronous.\n */\nFS.FileWorker.saveCopy = function (fsFile, storeName, options) {\n  options = options || {};\n\n  var storage = FS.StorageAdapter(storeName);\n  if (!storage) {\n    throw new Error('No store named \"' + storeName + '\" exists');\n  }\n\n  FS.debug && console.log('saving to store ' + storeName);\n\n  if (FS.TempStore.exists(fsFile)) {\n    var temp_chunk = FS.TempStore.Tracker.findOne({\n      fileId: fsFile._id\n    });\n    if (!temp_chunk || temp_chunk.is_saveCopy) {\n      return;\n    }\n    var filepath = path.join(Creator.steedosStorageDir+'/_tempstore', temp_chunk.keys[\"0\"]);\n    if (fs.existsSync(filepath)) {\n      var r = FS.TempStore.Tracker.update({\n        fileId: fsFile._id,\n        is_saveCopy: {\n          $exists: false\n        }\n      }, {\n        $set: {\n          is_saveCopy: true\n        }\n      });\n      if (r) {\n        var writeStream = storage.adapter.createWriteStream(fsFile);\n        var readStream = FS.TempStore.createReadStream(fsFile);\n        // Pipe the temp data into the storage adapter\n        readStream.pipe(writeStream);\n      }\n    }\n\n  }\n}"]}